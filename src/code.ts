// Plugin principal que permuta posi√ß√µes de elementos dentro de um frame
figma.showUI(__html__, { width: 350, height: 300 });

// Fun√ß√£o para detectar o grupo principal (maior elemento ou mais central)
function detectMainGroup(children: readonly SceneNode[]): SceneNode | null {
  if (children.length === 0) return null;
  
  // Estrat√©gia 1: Maior √°rea
  const byArea = [...children].sort((a, b) => (b.width * b.height) - (a.width * a.height));
  
  // Estrat√©gia 2: Mais central (baseado na posi√ß√£o no frame)
  const frameCenter = {
    x: Math.min(...children.map(c => c.x)) + (Math.max(...children.map(c => c.x + c.width)) - Math.min(...children.map(c => c.x))) / 2,
    y: Math.min(...children.map(c => c.y)) + (Math.max(...children.map(c => c.y + c.height)) - Math.min(...children.map(c => c.y))) / 2
  };
  
  const byPosition = [...children].sort((a, b) => {
    const distA = Math.sqrt(Math.pow(a.x + a.width/2 - frameCenter.x, 2) + Math.pow(a.y + a.height/2 - frameCenter.y, 2));
    const distB = Math.sqrt(Math.pow(b.x + b.width/2 - frameCenter.x, 2) + Math.pow(b.y + b.height/2 - frameCenter.y, 2));
    return distA - distB;
  });
  
  // Combina as estrat√©gias: se o maior tamb√©m est√° entre os 2 mais centrais, √© o principal
  const topByArea = byArea[0];
  const topTwoCentral = byPosition.slice(0, 2);
  
  if (topTwoCentral.includes(topByArea)) {
    return topByArea;
  }
  
  // Sen√£o, usa o mais central
  return byPosition[0];
}

// Fun√ß√£o para gerar m√∫ltiplas permuta√ß√µes
function generateMultiplePermutations(transforms: any[], count: number = 5): any[][] {
  const permutations = [];
  
  for (let i = 0; i < count; i++) {
    permutations.push(shuffleArray(transforms));
  }
  
  return permutations;
}

// Fun√ß√£o para carregar uma fonte espec√≠fica
async function loadFont(fontName: FontName) {
  try {
    await figma.loadFontAsync(fontName);
    return true;
  } catch (error) {
    console.warn(`N√£o foi poss√≠vel carregar a fonte: ${fontName.family} ${fontName.style}`);
    return false;
  }
}

// Fun√ß√£o para coletar todas as fontes √∫nicas de um elemento
function collectFonts(element: SceneNode): Set<string> {
  const fonts = new Set<string>();
  
  function collectFromNode(node: SceneNode) {
    if (node.type === "TEXT") {
      // Para textos com fonte √∫nica
      if (typeof node.fontName === 'object' && 'family' in node.fontName) {
        fonts.add(`${node.fontName.family}|${node.fontName.style}`);
      }
      // Para textos com fontes mistas (mixed)
      else if (node.fontName === figma.mixed) {
        // Percorre os caracteres para pegar todas as fontes
        const textLength = node.characters.length;
        for (let i = 0; i < textLength; i++) {
          const charFont = node.getRangeFontName(i, i + 1) as FontName;
          fonts.add(`${charFont.family}|${charFont.style}`);
        }
      }
    }
    
    if ('children' in node) {
      node.children.forEach(child => collectFromNode(child));
    }
  }
  
  collectFromNode(element);
  return fonts;
}

// Fun√ß√£o para ajustar estilos de texto proporcionalmente
async function adjustTextStyles(element: SceneNode, originalSize: {width: number, height: number}, newSize: {width: number, height: number}) {
  const scaleX = newSize.width / originalSize.width;
  const scaleY = newSize.height / originalSize.height;
  const averageScale = (scaleX + scaleY) / 2; // Usa escala m√©dia para manter legibilidade
  
  // Primeiro, coleta e carrega todas as fontes necess√°rias
  const fontStrings = collectFonts(element);
  const fontPromises = Array.from(fontStrings).map(fontString => {
    const [family, style] = fontString.split('|');
    return loadFont({ family, style });
  });
  
  // Aguarda todas as fontes serem carregadas
  await Promise.all(fontPromises);
  
  // Fun√ß√£o recursiva para ajustar textos em todos os n√≠veis
  function adjustTextInNode(node: SceneNode) {
    if (node.type === "TEXT") {
      // Ajusta o tamanho da fonte proporcionalmente
      const currentFontSize = node.fontSize as number;
      const newFontSize = Math.round(currentFontSize * averageScale);
      
      // Garante que o tamanho m√≠nimo seja 6px e m√°ximo 200px
      const clampedFontSize = Math.max(6, Math.min(200, newFontSize));
      
      node.fontSize = clampedFontSize;
      
      // Ajusta espa√ßamento de linha se necess√°rio
      if (node.lineHeight && typeof node.lineHeight === 'object' && node.lineHeight.unit === 'PIXELS') {
        node.lineHeight = {
          unit: 'PIXELS',
          value: Math.round(node.lineHeight.value * averageScale)
        };
      }
      
      // Ajusta espa√ßamento de caracteres se necess√°rio
      if (node.letterSpacing && typeof node.letterSpacing === 'object' && node.letterSpacing.unit === 'PIXELS') {
        node.letterSpacing = {
          unit: 'PIXELS',
          value: Math.round(node.letterSpacing.value * averageScale)
        };
      }
      
      // Ajusta espa√ßamento de par√°grafo se necess√°rio
      if (node.paragraphSpacing) {
        node.paragraphSpacing = Math.round(node.paragraphSpacing * averageScale);
      }
    }
    
    // Ajusta propriedades de layout para frames e grupos
    if (node.type === "FRAME" || node.type === "GROUP") {
      // Ajusta padding se for um auto layout
      if ('paddingTop' in node && node.paddingTop !== undefined) {
        node.paddingTop = Math.round(node.paddingTop * averageScale);
        node.paddingBottom = Math.round(node.paddingBottom * averageScale);
        node.paddingLeft = Math.round(node.paddingLeft * averageScale);
        node.paddingRight = Math.round(node.paddingRight * averageScale);
      }
      
      // Ajusta espa√ßamento entre itens se for auto layout
      if ('itemSpacing' in node && node.itemSpacing !== undefined) {
        node.itemSpacing = Math.round(node.itemSpacing * averageScale);
      }
    }
    
    // Ajusta propriedades de stroke
    if ('strokeWeight' in node && node.strokeWeight) {
      if (typeof node.strokeWeight === 'number') {
        node.strokeWeight = Math.max(0.5, Math.round(node.strokeWeight * averageScale));
      }
    }
    
    // Ajusta corner radius
    if ('cornerRadius' in node && node.cornerRadius && 'topLeftRadius' in node) {
      const scaledRadius = Math.round((node.cornerRadius as number) * averageScale);
      node.topLeftRadius = scaledRadius;
      node.topRightRadius = scaledRadius;
      node.bottomLeftRadius = scaledRadius;
      node.bottomRightRadius = scaledRadius;
    }
    
    // Se o n√≥ tem filhos, aplica recursivamente
    if ('children' in node) {
      node.children.forEach(child => adjustTextInNode(child));
    }
  }
  
  adjustTextInNode(element);
}

// Fun√ß√£o para embaralhar array (algoritmo Fisher-Yates)
function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

// Fun√ß√£o para duplicar um frame
function duplicateFrame(originalFrame) {
  const duplicatedFrame = originalFrame.clone();
  
  // Posiciona o frame duplicado ao lado do original
  duplicatedFrame.x = originalFrame.x + originalFrame.width + 50;
  duplicatedFrame.y = originalFrame.y;
  
  // Renomeia o frame
  duplicatedFrame.name = `${originalFrame.name} - Permuted`;
  
  return duplicatedFrame;
}

// Fun√ß√£o principal para gerar m√∫ltiplas varia√ß√µes
async function generateMultipleVariations(selectedElementId?: string | null) {
  const selection = figma.currentPage.selection;
  
  // Valida√ß√µes b√°sicas
  if (selection.length === 0) {
    figma.notify("‚ùå Selecione um frame para gerar varia√ß√µes!");
    return;
  }
  
  const selectedNode = selection[0];
  if (selectedNode.type !== "FRAME") {
    figma.notify("‚ùå Por favor, selecione um frame!");
    return;
  }
  
  const originalFrame = selectedNode;
  const children = [...originalFrame.children].filter(child => !child.locked);
  
  if (children.length < 2) {
    figma.notify("‚ùå Precisa de pelo menos 2 elementos para gerar varia√ß√µes!");
    return;
  }
  
  // Determina qual elemento vai trocar de posi√ß√£o
  let elementToSwap: SceneNode | null = null;
  
  if (selectedElementId) {
    // Usa o elemento especificado pelo usu√°rio
    elementToSwap = children.find(child => child.id === selectedElementId) || null;
    if (!elementToSwap) {
      figma.notify("‚ùå Elemento especificado n√£o encontrado!");
      return;
    }
  } else {
    // Detecta automaticamente o elemento principal
    elementToSwap = detectMainGroup(children);
    if (!elementToSwap) {
      figma.notify("‚ùå N√£o foi poss√≠vel detectar o elemento principal!");
      return;
    }
  }
  
  // Elementos que podem receber a posi√ß√£o do elemento selecionado
  const otherElements = children.filter(child => child.id !== elementToSwap!.id);
  
  if (otherElements.length < 1) {
    figma.notify("‚ùå Precisa de pelo menos 1 outro elemento para trocar!");
    return;
  }
  
  const notificationText = selectedElementId 
    ? `üîÑ "${elementToSwap.name}" vai trocar de posi√ß√£o com cada um dos outros elementos...`
    : `ü§ñ Elemento principal "${elementToSwap.name}" vai trocar de posi√ß√£o com cada um dos outros...`;
  
  figma.notify(notificationText, { timeout: 3000 });
  
  // Cria uma varia√ß√£o para cada elemento com o qual vai trocar
  const maxVariations = Math.min(5, otherElements.length);
  
  for (let i = 0; i < maxVariations; i++) {
    const newFrame = originalFrame.clone();
    newFrame.x = originalFrame.x + (originalFrame.width + 100) * (i + 1);
    newFrame.y = originalFrame.y;
    newFrame.name = `${originalFrame.name} - Troca ${i + 1}`;
    
    // Encontra os elementos correspondentes no novo frame
    const newElementToSwap = newFrame.children.find(child => {
      return child.name === elementToSwap!.name && 
             Math.abs(child.x - elementToSwap!.x) < 1 && 
             Math.abs(child.y - elementToSwap!.y) < 1;
    });
    
    const targetElement = otherElements[i];
    const newTargetElement = newFrame.children.find(child => {
      return child.name === targetElement.name && 
             Math.abs(child.x - targetElement.x) < 1 && 
             Math.abs(child.y - targetElement.y) < 1;
    });
    
    if (newElementToSwap && newTargetElement) {
      // Armazena as transforma√ß√µes originais
      const swapTransform = {
        x: newElementToSwap.x,
        y: newElementToSwap.y,
        width: newElementToSwap.width,
        height: newElementToSwap.height
      };
      
      const targetTransform = {
        x: newTargetElement.x,
        y: newTargetElement.y,
        width: newTargetElement.width,
        height: newTargetElement.height
      };
      
      // Realiza a troca de posi√ß√µes e dimens√µes
      try {
        // Move o elemento principal para a posi√ß√£o do alvo
        newElementToSwap.x = targetTransform.x;
        newElementToSwap.y = targetTransform.y;
        
        if ('resize' in newElementToSwap) {
          const originalSize = { width: swapTransform.width, height: swapTransform.height };
          const newSize = { width: targetTransform.width, height: targetTransform.height };
          
          newElementToSwap.resize(targetTransform.width, targetTransform.height);
          
          if (originalSize.width !== newSize.width || originalSize.height !== newSize.height) {
            await adjustTextStyles(newElementToSwap, originalSize, newSize);
          }
        }
        
        // Move o elemento alvo para a posi√ß√£o original do principal
        newTargetElement.x = swapTransform.x;
        newTargetElement.y = swapTransform.y;
        
        if ('resize' in newTargetElement) {
          const originalSize = { width: targetTransform.width, height: targetTransform.height };
          const newSize = { width: swapTransform.width, height: swapTransform.height };
          
          newTargetElement.resize(swapTransform.width, swapTransform.height);
          
          if (originalSize.width !== newSize.width || originalSize.height !== newSize.height) {
            await adjustTextStyles(newTargetElement, originalSize, newSize);
          }
        }
        
      } catch (error) {
        console.warn(`Erro ao trocar elementos:`, error);
      }
    }
  }
  
  figma.notify(`‚úÖ ${maxVariations} varia√ß√µes criadas! "${elementToSwap.name}" trocou de posi√ß√£o com diferentes elementos.`);
}

// Fun√ß√£o para incrementar a vers√£o no nome do frame (v1 -> v2, v2 -> v3, etc.)
function incrementFrameVersion(frameName: string, iteration: number): string {
    // Regex para encontrar padr√µes como v1, v2, v3a, v10b, etc.
    const versionRegex = /(_v)(\d+)([a-z]?)/i;
    const match = frameName.match(versionRegex);
    
    if (match) {
        // Se encontrou uma vers√£o, incrementa o n√∫mero
        const currentVersion = parseInt(match[2]);
        const newVersion = currentVersion + iteration;
        const letter = match[3]; // Preserva letra se existir (a, b, c...)
        
        return frameName.replace(versionRegex, `${match[1]}${newVersion}${letter}`);
    } else {
        // Se n√£o encontrou vers√£o, adiciona no final
        return `${frameName}_v${iteration + 1}`;
    }
}

// Nova fun√ß√£o para criar UMA varia√ß√£o de destaque
async function createSpotlightVariation(
    originalFrame: FrameNode,
    mainElementTransform: { x: number, y: number, width: number, height: number, name: string },
    promotedElementIndex: number, // √çndice do elemento que ser√° promovido
    promotedElementName: string, // Nome do elemento para refer√™ncia
    iteration: number // Para posicionamento do novo frame
): Promise<FrameNode> {
    const newFrame = originalFrame.clone();

    // Posiciona os novos frames em uma grade para melhor visualiza√ß√£o
    const framesPerRow = 5;
    const col = iteration % framesPerRow;
    const row = Math.floor(iteration / framesPerRow);
    newFrame.x = originalFrame.x + (originalFrame.width + 100) * col;
    newFrame.y = originalFrame.y + (originalFrame.height + 100) * (row + 1);

    // Incrementa a vers√£o no nome do frame
    newFrame.name = incrementFrameVersion(originalFrame.name, iteration + 1);

    // Pega os elementos desbloqueados do NOVO frame
    const newUnlockedChildren = newFrame.children.filter(c => !c.locked);
    
    if (promotedElementIndex >= newUnlockedChildren.length) {
        return newFrame;
    }

    const newPromotedElement = newUnlockedChildren[promotedElementIndex];

    // Encontra o elemento que est√° atualmente na posi√ß√£o principal
    const currentElementInMainSpot = newUnlockedChildren.find(c =>
        Math.abs(c.x - mainElementTransform.x) < 1 &&
        Math.abs(c.y - mainElementTransform.y) < 1 &&
        Math.abs(c.width - mainElementTransform.width) < 1 &&
        Math.abs(c.height - mainElementTransform.height) < 1
    );

    if (currentElementInMainSpot && currentElementInMainSpot !== newPromotedElement) {
        // Guarda as posi√ß√µes originais
        const originalPromotedTransform = {
            x: newPromotedElement.x, 
            y: newPromotedElement.y,
            width: newPromotedElement.width, 
            height: newPromotedElement.height
        };

        // 1. Elemento promovido vai para a posi√ß√£o principal
        newPromotedElement.x = mainElementTransform.x;
        newPromotedElement.y = mainElementTransform.y;
        newPromotedElement.resize(mainElementTransform.width, mainElementTransform.height);
        await adjustTextStyles(newPromotedElement, originalPromotedTransform, mainElementTransform);

        // 2. Elemento que estava no main vai para a posi√ß√£o do promovido
        currentElementInMainSpot.x = originalPromotedTransform.x;
        currentElementInMainSpot.y = originalPromotedTransform.y;
        currentElementInMainSpot.resize(originalPromotedTransform.width, originalPromotedTransform.height);
        await adjustTextStyles(currentElementInMainSpot, mainElementTransform, originalPromotedTransform);
    }
    // Se o elemento j√° √© o principal, mant√©m o nome com vers√£o incrementada
    
    return newFrame;
}

// Fun√ß√£o principal para gerar todas as varia√ß√µes de destaque
async function generateAllSpotlightVariations() {
    const selection = figma.currentPage.selection;

    if (selection.length === 0 || selection[0].type !== "FRAME") {
        figma.notify("‚ùå Selecione um frame para gerar as varia√ß√µes de destaque!", { error: true });
        return;
    }

    const originalFrame = selection[0];
    // Pegamos TODOS os filhos para garantir que todos tenham uma chance de serem o principal
    const allChildren = [...originalFrame.children];
    const unlockedChildren = allChildren.filter(child => !child.locked);

    if (unlockedChildren.length < 1) { // Precisa de pelo menos 1 elemento para ser principal
        figma.notify("‚ùå O frame n√£o possui elementos desbloqueados para testar.", { error: true });
        return;
    }

    // 1. Detecta qual √© o elemento principal atual, e guarda sua posi√ß√£o/tamanho de "trono"
    const currentMainElement = detectMainGroup(unlockedChildren);
    if (!currentMainElement) {
        figma.notify("‚ùå N√£o foi poss√≠vel detectar um elemento principal para usar como base.", { error: true });
        return;
    }

    const mainElementTransform = {
        x: currentMainElement.x, y: currentMainElement.y,
        width: currentMainElement.width, height: currentMainElement.height,
        name: currentMainElement.name // Para refer√™ncia
    };

    figma.notify(`üëë Gerando varia√ß√µes, promovendo cada elemento √† posi√ß√£o de destaque de "${currentMainElement.name}"...`, { timeout: 3000 });

    const newFrames: SceneNode[] = [];

    // Itera sobre CADA elemento desbloqueado para que ele se torne o "principal"
    for (let i = 0; i < unlockedChildren.length; i++) {
        const elementToPromote = unlockedChildren[i];

        const newFrame = await createSpotlightVariation(
            originalFrame,
            mainElementTransform,
            i, // √çndice do elemento
            elementToPromote.name, // Nome do elemento
            i // √çndice para posicionamento
        );
        newFrames.push(newFrame);
    }

    figma.currentPage.selection = newFrames;
    figma.viewport.scrollAndZoomIntoView(newFrames);
    figma.notify(`‚úÖ ${newFrames.length} varia√ß√µes de destaque criadas! Cada elemento foi promovido √† posi√ß√£o principal.`);
}

// Fun√ß√£o principal para permutar posi√ß√µes dos elementos (vers√£o original)
async function permuteElementPositions() {
  const selection = figma.currentPage.selection;
  
  // Verifica se h√° algo selecionado
  if (selection.length === 0) {
    figma.notify("‚ùå Selecione um frame para permutar as posi√ß√µes dos elementos!");
    return;
  }
  
  // Verifica se o primeiro item selecionado √© um frame
  const selectedNode = selection[0];
  if (selectedNode.type !== "FRAME") {
    figma.notify("‚ùå Por favor, selecione um frame!");
    return;
  }
  
  const originalFrame = selectedNode;
  
  // Filtra apenas elementos desbloqueados
  const children = [...originalFrame.children].filter(child => !child.locked);
  
  if (children.length === 0) {
    figma.notify("‚ùå O frame n√£o possui elementos desbloqueados para permutar!");
    return;
  }
  
  if (children.length < 2) {
    figma.notify("‚ùå O frame precisa ter pelo menos 2 elementos desbloqueados para permutar!");
    return;
  }
  
  // Mostra feedback de carregamento
  figma.notify("üîÑ Carregando fontes e processando...", { timeout: 2000 });
  
  // Coleta as posi√ß√µes e dimens√µes originais dos elementos
  const originalTransforms = children.map(child => ({
    x: child.x,
    y: child.y,
    width: child.width,
    height: child.height
  }));
  
  // Embaralha as transforma√ß√µes (posi√ß√µes + dimens√µes)
  const shuffledTransforms = shuffleArray(originalTransforms);
  
  // Duplica o frame original
  const newFrame = duplicateFrame(originalFrame);
  
  // Atualiza as posi√ß√µes e dimens√µes apenas dos elementos desbloqueados no frame duplicado
  let transformIndex = 0;
  
  for (const child of newFrame.children) {
    // S√≥ atualiza se o elemento n√£o est√° bloqueado
    if (!child.locked) {
      const transform = shuffledTransforms[transformIndex];
      const originalSize = { 
        width: child.width, 
        height: child.height 
      };
      const newSize = { 
        width: transform.width, 
        height: transform.height 
      };
      
      // Ajusta posi√ß√£o
      child.x = transform.x;
      child.y = transform.y;
      
      // Redimensiona o elemento
      child.resize(transform.width, transform.height);
      
      // Ajusta estilos de texto proporcionalmente se houve mudan√ßa de tamanho
      if (originalSize.width !== newSize.width || originalSize.height !== newSize.height) {
        await adjustTextStyles(child, originalSize, newSize);
      }
      
      transformIndex++;
    }
  }
  
  // Seleciona o novo frame criado
  figma.currentPage.selection = [newFrame];
  
  // Centraliza a visualiza√ß√£o no novo frame
  figma.viewport.scrollAndZoomIntoView([newFrame]);
  
  const lockedCount = originalFrame.children.length - children.length;
  const message = lockedCount > 0 
    ? `‚úÖ Frame duplicado! ${children.length} elementos permutados (${lockedCount} bloqueados ignorados)`
    : `‚úÖ Frame duplicado com ${children.length} elementos com posi√ß√µes e dimens√µes permutadas!`;
  
  figma.notify(message);
}

// Escuta mensagens da UI
figma.ui.onmessage = async (msg) => {
  if (msg.type === 'shuffle-elements') {
    await permuteElementPositions();
  } else if (msg.type === 'generate-variations') {
    await generateMultipleVariations(msg.selectedElementId);
  } else if (msg.type === 'generate-spotlight-variations') {
    await generateAllSpotlightVariations();
  } else if (msg.type === 'cancel') {
    figma.closePlugin();
  }
};

// Fun√ß√£o para enviar informa√ß√µes do frame para a UI
function sendFrameInfoToUI() {
  const selection = figma.currentPage.selection;
  if (selection.length > 0 && selection[0].type === "FRAME") {
    const frame = selection[0];
    const totalChildren = frame.children.length;
    const unlockedChildren = frame.children.filter(child => !child.locked);
    const lockedChildren = totalChildren - unlockedChildren.length;
    
    // Detecta o grupo principal
    const mainGroup = detectMainGroup(unlockedChildren);
    const permuteCount = mainGroup ? unlockedChildren.length - 1 : unlockedChildren.length;
    
    // Cria array com informa√ß√µes dos elementos para a UI
    const elementsInfo = frame.children.map(child => ({
      id: child.id,
      name: child.name,
      locked: child.locked || false,
      x: child.x,
      y: child.y,
      width: child.width,
      height: child.height
    }));
    
    // Envia informa√ß√µes para a UI
    figma.ui.postMessage({
      type: 'frame-selected',
      frameName: frame.name,
      childrenCount: totalChildren,
      unlockedCount: unlockedChildren.length,
      lockedCount: lockedChildren,
      mainGroupName: mainGroup ? mainGroup.name : 'Nenhum detectado',
      permuteCount: permuteCount,
      elements: elementsInfo
    });
  } else {
    // Nenhum frame selecionado
    figma.ui.postMessage({
      type: 'no-frame-selected'
    });
  }
}

// Listener para mudan√ßas na sele√ß√£o
figma.on("selectionchange", () => {
  sendFrameInfoToUI();
});

// Executa uma vez ao carregar o plugin
sendFrameInfoToUI();
